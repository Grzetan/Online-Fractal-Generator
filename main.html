<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas" width="500" height="500" style="border:1px solid #000000;"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.js" integrity="sha512-JLWfLWde2M173Tt7ju+tBz8OSzcfpCmkwK75AE2ErZYBWxN9143UWlIoHq8KrfBusmLu34d6SmHu3JwJHbufnw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var WIDTH = canvas.width;
var HEIGHT = canvas.height;

let xmin = -2;
let xmax = 2;
let ymin = -2;
let ymax = 2;
let maxIterations = 20;

const OPERATORS = {'-': 'Complex.subtract(', '+': 'Complex.add(', '/': 'Complex.div(', '*': 'Complex.multiply(', '^': 'Complex.pow('};

class Operation{
    constructor(type, first, second){
        this.type = type;
        this.first = first;
        this.second = second;
    }

    toString(){
        if(typeof this.first){
            this.first = this.first.toString();
        }

        if(typeof this.second){
            this.second = this.second.toString();
        }
        return OPERATORS[this.type] + this.first + ", " + this.second + ")";
    }
}

class Complex{
    constructor(re, im){
        this.re = re;
        this.im = im;
    }

    static abs(a){
        return a.re*a.re + a.im*a.im;
    }

    static add(a, b){
        return new Complex(a.re+b.re, a.im+b.im);
    }

    static substract(a, b){
        return new Complex(a.re-b.re, a.im-b.im);
    }

    static multiply(a, b){
        return new Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
    }

    static divide(a, b){
        return new Complex((a.re*b.re + a.im*b.im) / b.re*b.re + b.im*b.im, (a.im*b.re - a.re*b.im) / b.re*b.re + b.im*b.im);
    }

    static pow(a, power){
        let out = new Complex(a.re, a.im);
        let base = new Complex(a.re, a.im);
        for(let i=0; i<power-1; i++){
            out = Complex.multiply(out, base);
        }
        return out;
    }
}

function polishNotation2Code(formula){
    let splitted = formula.split(' ')
    
    let stack = [];
    let operations = [];

    for(let i=0; i<splitted.length; i++){
        console.log(splitted[i]);
        if(Object.keys(OPERATORS).includes(splitted[i])){
            // let second = 
            operations.push(new Operation(splitted[i], stack.shift(), stack.shift()));
            stack.push(operations.shift());
        }else{
            stack.push(splitted[i]);
        }
    }

    return new Function("z", "c", "return " + stack[0].toString());
}

let formula = "z 7 ^ c +";
const func = polishNotation2Code(formula);

for(let y=0; y<HEIGHT;y++){
    for(let x=0; x<WIDTH;x++){
        let c = new Complex(x/WIDTH * math.abs(xmax - xmin) + xmin, y/HEIGHT * math.abs(ymax - ymin) + ymin);
        let z  = new Complex(0,0);
        let i = 0;

        while(i<maxIterations){
            z = func(z, c);
            //If z is too high (goes to infinity), break out
            if(Complex.abs(z) > 5){
                break;
            }
            i++;
        }

        color = {red: 50, green: 50, blue: 50};
        if(i == maxIterations){
            color.red = 0;
            color.green = 0;
            color.blue = 0;
        }else if(i > 1){
            color.red = (i/maxIterations*255);
            color.green = 80;
            color.blue = 100;
        }
        ctx.fillStyle = `rgb(${color.red},${color.green},${color.blue})`;
        ctx.fillRect(x, y, 1, 1); // Fill a single pixel
    }
}
</script>
</body>
</html>