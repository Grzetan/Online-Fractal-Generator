<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas" width="900" height="900" style="border:1px solid #000000;"></canvas>

<script src="complex.js"></script>
<script id="vertex-shader" type="notjs">
attribute vec4 coordinates;

void main(void) {
  gl_Position = coordinates;
}
</script>

<!-- Mandelbrot set -->
<!-- <script id="fragment-shader" type="notjs">
precision highp float;

#define add(a, b) vec2(a.x+b.x, a.y+b.x)
#define substract(a, b) vec2(a.x-b.x, a.y-b.x)
#define mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
#define div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))

vec2 pow(vec2 a, float n) {
  float angle = atan(a.y, a.x);
  float r = length(a);
  float real = pow(r, n) * cos(n*angle);
  float im = pow(r, n) * sin(n*angle);
  return vec2(real, im);
}

uniform vec2 u_resolution;
  
void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  
  vec2 c = uv * 4.0 - vec2(2.0);
  vec2 z = vec2(0.0);
  bool escaped = false;
  int iterations = 0;

  for (int i = 0; i < 80; i++) {
    if (escaped) break;

    z = pow(z,2.0) + c;
    iterations = i;

    if (length(z) > 2.0) {
      escaped = true;
    }
  }
  gl_FragColor = escaped ? vec4(vec3(float(iterations)) / 80.0, 1.0) : vec4(vec3(0.0), 1.0);
}
</script> -->

<!-- Netwton fractal -->
<script id="fragment-shader" type="notjs">
precision mediump float;

#define add(a, b) vec2(a.x+b.x, a.y+b.x)
#define substract(a, b) vec2(a.x-b.x, a.y-b.x)
#define mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
#define div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))
#define abs(a) length(a)

vec2 pow(vec2 a, float n) {
  float angle = atan(a.y, a.x);
  float r = length(a);
  float real = pow(r, n) * cos(n*angle);
  float im = pow(r, n) * sin(n*angle);
  return vec2(real, im);
}

uniform vec2 u_resolution;

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec2 z = uv * 4.0 - 2.0;

  bool escaped = false;

  for (int i = 0; i < 100; i++) {
    if (escaped) break;

    vec2 delta = div((pow(z, 3.0) - vec2(1.0, 0.0)), (pow(z, 2.0) * 3.0));

    if (abs(delta) < 1e-6) {
      escaped = true;
    
      gl_FragColor = vec4((z.x + 2.0) / 4.0, (z.y + 2.0) / 4.0, 1.0, 1.0);
    }

    z = z - delta;
  }
}
</script>

<script>
var canvas = document.getElementById("canvas");
var gl = canvas.getContext("webgl");

if (!gl) {
  console.log("WebGL is not available in your browser.");
}

const vertices = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];

// Feed buffers with geometry
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
gl.bindBuffer(gl.ARRAY_BUFFER, null);


// Feed GPU with VERTEX shader and compile
const vertShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertShader, document.getElementById("vertex-shader").textContent);
gl.compileShader(vertShader);
console.log(gl.getShaderInfoLog(vertShader))

// Feed GPU with FRAGMENT shader and compile
const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragShader, document.getElementById("fragment-shader").textContent);
gl.compileShader(fragShader);
console.log(gl.getShaderInfoLog(fragShader))

// Initialize rendering program
const shaderProgram = gl.createProgram();
gl.attachShader(shaderProgram, vertShader);
gl.attachShader(shaderProgram, fragShader);
gl.linkProgram(shaderProgram);
gl.useProgram(shaderProgram);

// Bind shader attribute to buffer
const coord = gl.getAttribLocation(shaderProgram, "coordinates");
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.vertexAttribPointer(coord, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(coord);

// Draw
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.enable(gl.DEPTH_TEST);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.viewport(0,0,canvas.width,canvas.height);

// Set uniforms
const resolution = gl.getUniformLocation(shaderProgram, "u_resolution");
gl.uniform2f(resolution, canvas.width, canvas.height);

gl.drawArrays(gl.TRIANGLES, 0, 6);

// var ctx = canvas.getContext('2d');
// var WIDTH = canvas.width;
// var HEIGHT = canvas.height;

// ctx.fillStyle = 'black';
// ctx.fillRect(0,0, WIDTH, HEIGHT);

// let xmin = -2;
// let xmax = 2;
// let ymin = -2;
// let ymax = 2;
// let maxIterations = 20;

// const OPERATORS = {'-': {code: 'sub(', associativity: 'left', precedence: 1}, 
//                    '+': {code: 'add(', associativity: 'left', precedence: 1}, 
//                    '/': {code: 'div(', associativity: 'left', precedence: 2}, 
//                    '*': {code: 'mul(', associativity: 'left', precedence: 2}, 
//                    '^': {code: 'pow(', associativity: 'right', precedence: 3}};

// const FUNCTIONS = {
//     'len': {code: 'len()'},
//     'abs': {code: 'abs()'},
//     'sin': {code: 'sin()'},
//     'conj': {code: 'conjugate()'},
//     'neg': {code: 'neg()'},
//     'inv': {code: 'inverse()'}

// }

// class Operation{
//     constructor(type, first, second){
//         this.type = type;
//         this.first = first;
//         this.second = second;
//     }

//     toString(){
//         return OPERATORS[this.type].code + this.first + ', ' + this.second + ")";
//     }
// }

// function removeAfterChar(inputString, charToRemove) {
//   const charIndex = inputString.indexOf(charToRemove);
  
//   if (charIndex !== -1) {
//     return inputString.substring(0, charIndex);
//   }
  
//   return inputString;
// }

// function extractStringInParentheses(inputString) {
//   const regex = /\(([^)]+)\)/;
//   const match = inputString.match(regex);

//   if (match && match.length > 1) {
//     return match[1];
//   }

//   return null;
// }

// function polishNotation2Code(formula){
//     let splitted = formula.split(' ')
//     console.log(splitted);

//     for(let i=0; i<splitted.length; i++){
//         let operation = removeAfterChar(splitted[i], '(');
//         if(Object.keys(FUNCTIONS).includes(operation)){
//             let content = extractStringInParentheses(splitted[i]);
//             console.log(content);
//             splitted[i] = content + "." + FUNCTIONS[operation].code;
//         }
//     }

//     let stack = [];
//     let mainOperation = new Operation();

//     for(let i=0; i<splitted.length; i++){
//         if(Object.keys(OPERATORS).includes(splitted[i])){
//             let second = stack.pop();
//             let first = stack.pop();
//             let operation = new Operation(splitted[i], first, second);
//             stack.push(operation.toString());
//         }else{
//             stack.push(splitted[i]);
//         }
//     }

//     let output = stack[0].toString();

//     console.log(output);

//     return new Function("z", "c", "return " + output);
// }

// // https://www.andreinc.net/2010/10/05/converting-infix-to-rpn-shunting-yard-algorithm
// function formula2RPN(formula){
//     splitted = formula.split(' ');
//     output = [];
//     stack = [];
//     for(let i=0; i<splitted.length; i++){
//         if(Object.keys(OPERATORS).includes(splitted[i])){
//             while(stack.length != 0 && Object.keys(OPERATORS).includes(stack[stack.length-1])){
//                 const curr = OPERATORS[splitted[i]];
//                 const next = OPERATORS[stack[stack.length-1]];
//                 if((curr.associativity == 'left' && next.precedence >= curr.precedence) ||
//                    (curr.associativity == 'right' && next.precedence > curr.precedence)){
//                     output.push(stack.pop());
//                     continue;
//                 }
//                 break;
//             }
//             stack.push(splitted[i]);
//         }else if(splitted[i] == '('){
//             stack.push(splitted[i]);
//         }else if(splitted[i] == ')'){
//             while(stack.length != 0 && stack[stack.length-1] != '('){
//                 output.push(stack.pop());
//             }
//             stack.pop();
//         }else{
//             output.push(splitted[i]);
//         }
//     }

//     while(stack.length != 0){
//         output.push(stack.pop());
//     }

//     return output.join(' ');
// }

// let formula = "( z ^ 4.0 - vec2(1.0) ) / ( z ^ 3.0 * vec2(4.0) )";
// const RPN = formula2RPN(formula);
// console.log(RPN);
// const func = polishNotation2Code(RPN);

// // Generate mandelbrot

// // for(let y=0; y<HEIGHT;y++){
// //     for(let x=0; x<WIDTH;x++){
// //         let c = new Complex(x/WIDTH * Math.abs(xmax - xmin) + xmin, y/HEIGHT * Math.abs(ymax - ymin) + ymin);
// //         let z  = new Complex(0,0);
// //         let i = 0;

// //         while(i<maxIterations){
// //             z = func(z, c);
// //             //If z is too high (goes to infinity), break out
// //             if(z.abs() > 5){
// //                 break;
// //             }
// //             i++;
// //         }

// //         color = {red: 50, green: 50, blue: 50};
// //         if(i == maxIterations){
// //             color.red = 0;
// //             color.green = 0;
// //             color.blue = 0;
// //         }else if(i > 1){
// //             color.red = (i/maxIterations*255);
// //             color.green = 80;
// //             color.blue = 100;
// //         }
// //         ctx.fillStyle = `rgb(${color.red},${color.green},${color.blue})`;
// //         ctx.fillRect(x, y, 1, 1); // Fill a single pixel
// //     }
// // }

// // Generate netwon fractals
// function getRandomIntInclusive(min=0, max=255) {
//   min = Math.ceil(min);
//   max = Math.floor(max);
//   return Math.floor(Math.random() * (max - min + 1) + min); // The maximum is inclusive and the minimum is inclusive
// }

// let roots = []

// let c = new Complex(-0.3,0);
// for(let y=0; y<HEIGHT;y++){
//     console.log(y, HEIGHT)
//     for(let x=0; x<WIDTH;x++){
//         let z = new Complex(x/WIDTH * Math.abs(xmax - xmin) + xmin, y/HEIGHT * Math.abs(ymax - ymin) + ymin);
//         let i = 0;

//         while(i<100){
//             let delta = func(z, c);
//             //If z is too high (goes to infinity), break out
//             if(delta.abs() < 1e-12){
//                 let closestRoot = null;
//                 for(let j=0; j<roots.length; j++){
//                     let tmp = roots[j].root;
//                     let dist = tmp.sub(z);
//                     if(dist.abs() < 1e-8){
//                         closestRoot = roots[j];
//                         break;
//                     }
//                 }

//                 if(closestRoot == null){
//                     roots.push({root: z, color: {red: getRandomIntInclusive(), green: getRandomIntInclusive(), blue: getRandomIntInclusive()}});
//                     closestRoot = roots[roots.length-1];
//                 }

//                 ctx.fillStyle = `rgb(${closestRoot.color.red},${closestRoot.color.green},${closestRoot.color.blue})`;
//                 ctx.fillRect(x, y, 1, 1);

//                 break;
//             }
//             z = z.sub(delta);
//             i++;
//         }
//     }
// }

// console.log(roots)
</script>
</body>
</html>