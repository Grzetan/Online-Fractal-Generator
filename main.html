<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas" width="500" height="500" style="border:1px solid #000000;"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.js" integrity="sha512-JLWfLWde2M173Tt7ju+tBz8OSzcfpCmkwK75AE2ErZYBWxN9143UWlIoHq8KrfBusmLu34d6SmHu3JwJHbufnw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var WIDTH = canvas.width;
var HEIGHT = canvas.height;

let xmin = -2;
let xmax = 2;
let ymin = -2;
let ymax = 2;
let maxIterations = 20;

const OPERATORS = {'-': {code: 'math.subtract(', associativity: 'left', precedence: 1}, 
                   '+': {code: 'math.add(', associativity: 'left', precedence: 1}, 
                   '/': {code: 'math.divide(', associativity: 'left', precedence: 2}, 
                   '*': {code: 'math.multiply(', associativity: 'left', precedence: 2}, 
                   '^': {code: 'math.pow(', associativity: 'right', precedence: 3}};

const FUNCTIONS = {
    'len': {code: 'Complex.len'},
    'abs': {code: 'Complex.abs'},
    'sin': {code: 'Complex.sin'}
}

class Operation{
    constructor(type, first, second){
        this.type = type;
        this.first = first;
        this.second = second;
    }

    toString(){
        return OPERATORS[this.type].code + this.first + ", " + this.second + ")";
    }
}

class Complex{
    constructor(re, im){
        this.re = re;
        this.im = im;
    }

    static getComplex(a){
        if(typeof a == Number){
            return new Complex(a, 0);
        }

        return a;
    }

    static len(a){
        return a.re*a.re + a.im*a.im;
    }

    static abs(a){
        return new Complex(math.abs(a.re), math.abs(a.im));
    }

    static add(a, b){
        a = this.getComplex(a);
        b = this.getComplex(a);
        return new Complex(a.re+b.re, a.im+b.im);
    }

    static subtract(a, b){
        a = this.getComplex(a);
        b = this.getComplex(a);
        return new Complex(a.re-b.re, a.im-b.im);
    }

    static multiply(a, b){
        a = this.getComplex(a);
        b = this.getComplex(a);
        return new Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
    }

    static divide(a, b){
        a = this.getComplex(a);
        b = this.getComplex(a);
        return new Complex((a.re*b.re + a.im*b.im) / b.re*b.re + b.im*b.im, (a.im*b.re - a.re*b.im) / b.re*b.re + b.im*b.im);
    }

    static pow(a, power){
        a = this.getComplex(a);

        let out = new Complex(a.re, a.im);
        let base = new Complex(a.re, a.im);
        for(let i=0; i<power-1; i++){
            out = Complex.multiply(out, base);
        }
        return out;
    }
}

function polishNotation2Code(formula){
    let splitted = formula.split(' ')
    console.log(splitted);
    let stack = [];
    let mainOperation = new Operation();

    for(let i=0; i<splitted.length; i++){
        if(Object.keys(OPERATORS).includes(splitted[i])){
            let second = stack.pop();
            let first = stack.pop();
            let operation = new Operation(splitted[i], first, second);
            stack.push(operation.toString());
        }else{
            stack.push(splitted[i]);
        }
    }

    let output = stack[0].toString();

    let keys = Object.keys(FUNCTIONS);
    for(let i=0; i<keys.length; i++){
        output = output.replace(keys[i], FUNCTIONS[keys[i]].code)
    }

    console.log(output);

    return new Function("z", "c", "return " + output);
}

// https://www.andreinc.net/2010/10/05/converting-infix-to-rpn-shunting-yard-algorithm
function formula2RPN(formula){
    splitted = formula.split(' ');
    output = [];
    stack = [];
    for(let i=0; i<splitted.length; i++){
        if(Object.keys(OPERATORS).includes(splitted[i])){
            while(stack.length != 0 && Object.keys(OPERATORS).includes(stack[stack.length-1])){
                const curr = OPERATORS[splitted[i]];
                const next = OPERATORS[stack[stack.length-1]];
                if((curr.associativity == 'left' && next.precedence >= curr.precedence) ||
                   (curr.associativity == 'right' && next.precedence > curr.precedence)){
                    output.push(stack.pop());
                    continue;
                }
                break;
            }
            stack.push(splitted[i]);
        }else if(splitted[i] == '('){
            stack.push(splitted[i]);
        }else if(splitted[i] == ')'){
            while(stack.length != 0 && stack[stack.length-1] != '('){
                output.push(stack.pop());
            }
            stack.pop();
        }else{
            output.push(splitted[i]);
        }
    }

    while(stack.length != 0){
        output.push(stack.pop());
    }

    return output.join(' ');
}

let formula = "z - ( z ^ 3 - 1 ) / ( 3 * z ^ 2 )";
const RPN = formula2RPN(formula);
console.log(RPN);
const func = polishNotation2Code(RPN);

for(let y=0; y<HEIGHT;y++){
    for(let x=0; x<WIDTH;x++){
        let c = new math.Complex(x/WIDTH * math.abs(xmax - xmin) + xmin, y/HEIGHT * math.abs(ymax - ymin) + ymin);
        let z  = new math.Complex(0,0);
        let i = 0;

        while(i<maxIterations){
            z = func(z, c);
            //If z is too high (goes to infinity), break out
            if(Complex.len(z) > 5){
                break;
            }
            i++;
        }

        color = {red: 50, green: 50, blue: 50};
        if(i == maxIterations){
            color.red = 0;
            color.green = 0;
            color.blue = 0;
        }else if(i > 1){
            color.red = (i/maxIterations*255);
            color.green = 80;
            color.blue = 100;
        }
        ctx.fillStyle = `rgb(${color.red},${color.green},${color.blue})`;
        ctx.fillRect(x, y, 1, 1); // Fill a single pixel
    }
}
</script>
</body>
</html>